<!DOCTYPE html>
<!-- saved from url=(0050)https://www.severcart.ru/blog/all/python_channels/ -->
<html class="" lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="yandex-verification" content="34065f1981b9eef1">    
    
    <title>Создание чата с использованием Django Channels</title>
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="description" content="WebSockets – это новый протокол связи, который обеспечивает полнодуплексные каналы связи по одному TCP соединению и хорошо подходит для приложений реального времени.">
    <meta name="keywords" content="django, channels">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="https://www.severcart.ru/static/img/favicon2.ico" type="image/x-icon">
    <link rel="stylesheet" href="./Создание чата с использованием Django Channels_files/foundation.min.css">
	<meta name="rpc12ff383d1324432b17195d879b9d4d1" content="13f2cf674db1913734a787202c9b8e9b">
    <link rel="stylesheet" href="./Создание чата с использованием Django Channels_files/app.css">
    <link rel="stylesheet" href="./Создание чата с использованием Django Channels_files/mobile.css">
    <link rel="home" type="application/rss+xml" href="https://www.severcart.ru/feed/">
    
<link rel="index" href="https://www.severcart.ru/blog/">
<link rel="prev" href="https://www.severcart.ru/blog/all/context_managers_in_python/">
<link rel="next" href="https://www.severcart.ru/blog/all/command_line_crop_image/">

    
    <!-- Yandex.Metrika counter -->
<script async="" src="./Создание чата с использованием Django Channels_files/analytics.js"></script><script async="" src="./Создание чата с использованием Django Channels_files/tag.js"></script><script type="text/javascript">
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(35746280, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/35746280" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->    
    <!-- Google analitics -->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-87793225-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- Google analitics -->
    
<script src="./Создание чата с использованием Django Channels_files/embed.js" data-timestamp="1583948482368"></script><link rel="prefetch" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.91790a929b2fba6bf8967d2204d948d5.css"><link rel="prefetch" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.b9167d06dc7bd01b59d6d6332d6aafa1.js"><link rel="prefetch" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.b9f55e00ac59a682cfbac91eadf883d4.js"><link rel="prefetch" as="script" href="https://disqus.com/next/config.js"><meta class="foundation-mq"><script src="./Создание чата с использованием Django Channels_files/alfalfalfa.0823c767a3bc925f628afd9bed26c958.js" async="" charset="UTF-8"></script></head>
<body>
    <div class="wrapper">
            <div class="contact">
                <span class="mail"><a href="mailto:info@severcart.ru">info@severcart.ru</a></span>
            </div>
                <div class="row">
            <div class="large-12 columns">
                <div class="row">
                    <div class="header">
                        <div class="large-3 medium-3 columns text-left">
                            
                            
                                <a href="https://www.severcart.ru/"><img alt="Severcart logotipe" src="./Создание чата с использованием Django Channels_files/logo2.png" title="На главную" class="logo"></a>
                            
                        </div>
                        <div class="large-9 medium-9 columns">
                            <div class="main-menu">
                                <ul>
                                    <li>
                                        
                                        
                                            <a href="https://www.severcart.ru/">Главная</a>
                                        
                                    </li>
                                    <li>
                                        
                                        
                                            <a href="https://www.severcart.ru/comp/">Купить</a>
                                        
                                    </li>
                                    <li>
                                        
                                        
                                            <a href="https://www.severcart.ru/downloads/">Скачать</a>
                                        
                                    </li>
                                    <li><a href="https://www.severcart.ru/docs/">Документация</a></li><li><a rel="nofollow" href="http://demo.severcart.ru/">Демо</a></li><li><a href="https://www.severcart.ru/blog/">Блог</a></li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="content">
        
<div class="row">
    <div class="large-8 columns">
        <div class="blog-content"><!-- Главный контент -->
            <div class="e2-only e2-note">
                <article>
                    <h1 class="e2-published e2-smart-title">Создание чата с использованием Django Channels</h1>
                    <div class="e2-note-tags">
                        <span class="e2-date" title="8 января 2018 г.">8 января 2018 г.</span>
                        &nbsp;&nbsp;&nbsp;<a class="e2-category" href="https://www.severcart.ru/blog/category/Django/">Django</a>
                        
                    </div>
                    <div class="e2-note-text e2-text e2-published">
                        <p>Стандартное Django приложение обрабатывает HTTP запросы, используя рабочий цикл запрос-ответ. Запрос создаётся браузером пользователя, далее он выполняется соответствующим Django view, которое возвращает ответ пользователю. Цикл запрос-ответ не подходит для приложений реального времени, которые требуют частых запросов к серверу. Новые стандарты, такие как websockets и HTTP2 позволяют устранить некоторые из этих недостатков. WebSockets – это новый протокол связи, который обеспечивает полнодуплексные каналы связи по одному TCP соединению и хорошо подходит для приложений реального времени. Открытие и поддержание соединения с сервером с помощью websocket очень дёшево с точки зрения потребления памяти и вычислительных ресурсов процессора. </p>

<p>Пакет Channels расширяет возможности Django, позволяя обрабатывать websocket соединения подобно обычным views. Channels представляет собой упорядоченную FIFO очередь продвигаемых сообщений с доставкой только одному листенеру. Проще говоря, сhannel является очередью задач, которая принимает сообщения от производителей и доставляет их потребителям.</p>

<p>Обработка websocket запроса в Django производится двумя процессами.</p>

<ul>
<li>Интерфейс сервер – обрабатывает входящее соединение по HTTP и Websocket.</li>
<li>Рабочий процесс, запускает views для обработки websocket и http запросов.</li>
</ul>

<p>Обмен данными между ними производится по протоколу ASGI, которые роутятся через Redis. Стоит отметить, поскольку интерфейсный сервер и рабочий процесс в Channels разъединены, можно добавлять и удалять рабочие процессы, не закрывая websocket соединения.</p>

<p>Следующая схема иллюстрирует, как Django обслуживает запросы традиционным способом и с использованием Channels:</p>

<p><strong>Django обрабатывает только HTTP.</strong></p>

<p>Браузер &lt;——–&gt; Web сервер &lt;——–&gt; Django View функция</p>

<p><strong>Django с Channels</strong>
Браузер &lt;——–&gt; Интерфейс сервер &lt;——–&gt; Слой Channel &lt;——–&gt; Django View функция + Websocket Consumer</p>

<p>Web сервер – работает с http соединениями (спасибо КэП).
Интерфейс сервер – обрабатывает HTTP и websocket соединения.
Слой Channel – HTTP транспорт websocket сообщения рабочим процессам, которые являются обычными Django представлениями, также известными как обработчики Channels.</p>

<p>Обратите внимание, что это упрощенная схема работы. В продашен развертываниях эта схема, вероятно, будет отличаться. 
В качестве другого примера можно запустить WSGI-сервер вместе с процессами обработки websocket для обслуживания обычных HTTP запросов Django.</p>

<p>Темы по созданию Django проекта с нуля, настройка системы аутентификации, миграции схемы, CBV и т. д. освещаться здесь не будут, потому что предполагается, что читатель достаточно опытный разработчик.</p>

<p>Инструкции по установке Channels.</p>

<ol>
<li>pip install channels</li>
<li>Добавляем channels в INSTALLED_APPS файла settings.py</li>
<li>Устанавливаем redis</li>
</ol>

<p>Функциональности чата будут минимальными:</p>

<ul>
<li>одна чат комната, где пользователи могут переписываться между собой;</li>
<li>столбец для отображения зарегистрированных пользователей, которые в настоящее время подключены, а также количество зрителей, то есть людей, которые просматривают чат, но не вошли в систему.</li>
</ul>

<p>Часто упускаемый из виду многими чатами момент неправильного подсчёта количества подключённых пользователей. Это происходит потому, что существует разновидность событий, которые заставляют клиентов отключаться от websocket соединений, не уведомляя об этом сервер. У сервера нет простого способа обновления количества пользователей, подключенных к чат-комнате без периодического процесса дисконнекта. Справиться с этой ситуацией помогает Django пакет django-channels-presence. Он позволяет закрывать устаревшие соединения с веб-сайтом и точно подсчитывает количество подключённых к чату пользователей. Как это работает? Чтобы отслеживать какие websockets всё ещё подключены, необходимо регулярно обновлять временную метку last_seen для всех существующих подключений и периодически удалять соединения, если от них не было отклика непродолжительное время.</p>

<p>Итак, перейдём к коду. У нас будет одна жестко закодированная комната all, для того чтобы не создавать отдельную Room модель. Модель пользовательского сообщения чата:</p>

<pre><code>class ChatMessage(models.Model):
    """
    Модель для представления сообщения чата
    """

    #Поля
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    message = models.TextField(max_length=3000)
    message_html = models.TextField()
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)

    def __str__(self):
        """
        Строка для представления сообщения
        """

        return self.message
</code></pre>

<p>Поля модели:</p>

<ul>
<li>user – ForeignKey на модель  User;</li>
<li>message – необработанный текст, который пользователь вводит в поле чата;</li>
<li><p>message_html – это html-версия сообщения. html версия будет экранирована, в чат-комнате будут разрешены только теги ссылок. Все остальные теги, такие как &lt;script&gt; <!-- script-->, не будут работать. Основная причина для создания html версии каждого сообщения чата – это экономия на обработке ресурсов, избегая рендеринга одного и того же html каждый раз после каждого запроса.</p>

<pre><code>class IndexView(generic.View):

        def get(self, request):
            #Показ последних 10 сообщений
            chat_queryset = ChatMessage.objects.order_by("-created")[:10]
            chat_message_count = len(chat_queryset)
            if chat_message_count &gt; 0:
                first_message_id = chat_queryset[len(chat_queryset)-1].id
            else:
                first_message_id = -1
            previous_id = -1
            if first_message_id != -1:
                try:
                    previous_id =         ChatMessage.objects.filter(pk__lt=first_message_id).order_by("-pk")[:1][0].id
                except IndexError:
                    previous_id = -1
            chat_messages = reversed(chat_queryset)

         return render(request, "chatdemo/chatroom.html", {
        'chat_messages': chat_messages,
        'first_message_id' : previous_id,
    })
</code></pre></li>
</ul>

<p>IndexView извлекает последние 10 сообщений, опубликованных за последнее время в чате и устанавливает следующие переменные:
first_message – идентификатор первого сообщения в прокрутке чата. Например, наша база данных содержит сообщения с id 4,3,2,1. Мы отправляем 4,3,2 для отображения в окне чата. Когда пользователь нажимает на кнопку «Load previous messages» из комнаты чата, загружаются все оставшиеся сообщения. В нашем случае это будет 1.</p>

<p>Чат рендерится с помощью шаблона chatroom.html.</p>

<p>Теперь, когда есть страница в чате отображающая десять последних сообщений, можем приступить к разработке обработчиков websocket подключений, которые позволяют пользователям отправлять чат-сообщение, а также загружать предыдущие сообщения чата. Структура файла, которая позволяет это сделать, проста: определяем маршруты в routing.py, которая является Channels версией urls.py, и определяем потребителей (представления) в users.py, которая является Channels версией views.py.</p>

<p>Определим 2 url в routing.py:</p>

<ul>
<li>/ws/ – куда будут направляться сообщения чата;</li>
<li>/loadhistory/ – обрабатывает запросы для предыдущих сообщений чата;</li>
</ul>

<p>Каждая url содержит обработчики 3х событий:</p>

<ul>
<li>websocket.connect – вызывается при открытии нового подключения;</li>
<li>websocket.receive – обрабатывает фактическое сообщение, которое является либо чат-сообщением от пользователя, либо запросом истории чата;</li>
<li>websocket.disconnect – вызывается, когда клиент отключается от чата.</li>
</ul>

<p>Код для routing.py, где определены указанные websocket url:</p>

<pre><code>from channels.routing import route
from channels import include
from chatdemo.consumers import chat_connect, chat_disconnect, chat_receive, loadhistory_connect, loadhistory_disconnect, loadhistory_receive

chat_routing = [
    route("websocket.connect", chat_connect),
    route("websocket.receive", chat_receive),
    route("websocket.disconnect", chat_disconnect)
]

loadhistory_routing = [
    route("websocket.connect", loadhistory_connect),
    route("websocket.receive", loadhistory_receive),
    route("websocket.disconnect", loadhistory_disconnect)
]

channel_routing = [
    include(chat_routing, path=r"^/ws/$"),
    include(loadhistory_routing, path=r"^/loadhistory/$"),
]
</code></pre>

<p>Перед определением представлений, обрабатывающих запросы websocket в файле customers.py, рассмотрим, как сообщения чата обрабатываются в Django Channels.</p>

<p>Когда пользователь устанавливает веб соединения с url /ws/ происходят следующие процессы:</p>

<ul>
<li>reply_channel соединения добавляются в группу all. Зачем это нужно? Все пользователи будут частью группы, которая позволяет нам отправлять чат сообщения одним-ко многим. Например, когда User A отправляет сообщение, все пользователи, подключенные к all группе, получат это сообщение.</li>
<li>Соединение также добавляется в комнаты all. Room здесь относится к модели в пакете channels_presence. Используется для отслеживания количества подключенных к чат комнате пользователей.</li>
<li>В завершение, пользователю направляется ответ {"accept": True} для подтверждения принятия подключения.</li>
</ul>

<p>Код, который только что обсуждали:</p>

<pre><code>@channel_session_user_from_http
def chat_connect(message):
    Group("all").add(message.reply_channel)
    Room.objects.add("all", message.reply_channel.name, message.user)
    message.reply_channel.send({"accept": True})
</code></pre>

<p>Перейдем к коду, который обрабатывает сообщения чата. Описание того, что происходит внутри функции:</p>

<ul>
<li>Получить и декодировать сообщение json;</li>
<li>Подтвердить, что json содержит ключ message, который определяет сообщение;</li>
<li>Подтверждение пользовательской аутентификации, так как не имеет смысла принимать сообщения чата от неаутентифицированных пользователей;</li>
<li>Экранируем сообщение с помощью функции escape из django.utils.html;</li>
<li>Проверка, содержит ли сообщение какие-либо URL адреса и преобразует их в ссылки;</li>
<li><p>Возвращение json, содержащий имя пользователя и html сообщение.
Реализация вышеуказанного описания:</p>

<pre><code>@touch_presence
@channel_session_user
def chat_receive(message):
        data = json.loads(message['text'])
        if not data['message']:
                return
        if not message.user.is_authenticated:
                return
        current_message = escape(data['message'])
        urlRegex = re.compile(
        u'(?isu)(\\b(?:https?://|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}/)[^\\s()&lt;'
        u'&gt;\\[\\]]+[^\\s`!()\\[\\]{};:\'".,&lt;&gt;?\xab\xbb\u201c\u201d\u2018\u2019])'
    )

processed_urls = list()
for obj in urlRegex.finditer(current_message):
    old_url = obj.group(0)
    if old_url in processed_urls:
        continue
    processed_urls.append(old_url)
    new_url = old_url
    if not old_url.startswith(('http://', 'https://')):
        new_url = 'http://' + new_url
    new_url = '&lt;a href="' + new_url + '"&gt;' + new_url + "&lt;/a&gt;"
    current_message = current_message.replace(old_url, new_url)
m = ChatMessage(user=message.user, message=data['message'], message_html=current_message)
m.save()

my_dict = {'user' : m.user.username, 'message' : current_message}
Group("all").send({'text': json.dumps(my_dict)})
</code></pre></li>
</ul>

<p>Декоратор @touch_presence используется, чтобы зафиксировать периодический пульс, отправленный из браузера пользователя, который гарантирует, что пользователь не будет удалён из списка активных подключенных к чату пользователей.</p>

<p>В завершение, функция chat_disconnect просто удаляет пользователя из группы all и комнаты.</p>

<pre><code>@channel_session_user
def chat_disconnect(message):
    Group("all").discard(message.reply_channel)
    Room.objects.remove("all", message.reply_channel.name)
</code></pre>

<p>Рассмотрим функцию, которая отправляет список зарегистрированных и анонимных пользователей. Эта функция вызывается каждый раз, когда пользователь подключается или отключается от чата.</p>

<pre><code>@receiver(presence_changed)
def broadcast_presence(sender, room, **kwargs):
    # Широковещательная рассылка списка новых пользователей в комнате.
    Group(room.channel_name).send({
        'text': json.dumps({
            'type': 'presence',
            'payload': {
                'channel_name': room.channel_name,
                'members': [user.username for user in room.get_users()],
                'lurkers': int(room.get_anonymous_count()),
            }
        })
    })
</code></pre>

<p>Возвращаемый json содержит данные:</p>

<ul>
<li>список зарегистрированных пользователей, подключенных к чату;</li>
<li>lurkers – количество анонимных пользователей.</li>
</ul>

<p>Переходя к второй url /loadhistory/, функция loadhistory_connect (message) принимает соединение websocket, отправляет стандартный ответ, чтобы указать, что соединение принято: {"accept": True}. При завершении соединения дополнительных действий не требуется.</p>

<pre><code>@channel_session_user_from_http
def loadhistory_connect(message):
    message.reply_channel.send({"accept": True})

@channel_session_user
def loadhistory_disconnect(message):
    pass
</code></pre>

<p>Функция loadhistory_receive выполняет следующие действия:</p>

<ul>
<li>Декодирует json и извлекает идентификатор сообщения чата last_message_id;</li>
<li>Выполняет запрос к базе данных для извлечения 10 сообщений (если они существуют) с идентификатором, меньшим или равным last_message_id, и возвращает сообщения чата в формате json.</li>
</ul>

<p>Код:</p>

<pre><code>@channel_session_user
def loadhistory_receive(message):
    data = json.loads(message['text'])
    chat_queryset = ChatMessage.objects.filter(id__lte=data['last_message_id']).order_by("-created")[:10]
    chat_message_count = len(chat_queryset)
    if chat_message_count &gt; 0:
        first_message_id = chat_queryset[len(chat_queryset)-1].id
    else:
        first_message_id = -1
    previous_id = -1
    if first_message_id != -1:
        try:
            previous_id = ChatMessage.objects.filter(pk__lt=first_message_id).order_by("-pk")[:1][0].id
        except IndexError:
            previous_id = -1

    chat_messages = reversed(chat_queryset)
    cleaned_chat_messages = list()
    for item in chat_messages:
        current_message = item.message_html
        cleaned_item = {'user' : item.user.username, 'message' : current_message }
        cleaned_chat_messages.append(cleaned_item)

    my_dict = { 'messages' : cleaned_chat_messages, 'previous_id' : previous_id }
    message.reply_channel.send({'text': json.dumps(my_dict)})
</code></pre>

<p>Теперь реализованы все websocket url, поэтому перейдём к клиентскому JavaScript, который обращается к этим url.</p>

<p>Прежде чем перейти к JavaScript обратим внимание на библиотеку Reconnecting websockets, она предназначена для автоматического восстановления закрытого соединения из-за того, что websockets не восстанавливают подключений если оно было закрыто.</p>

<p>2 клиентских JavaScript файла:</p>

<ul>
<li>realtime.js – обрабатывает сообщения чата;</li>
<li>loadhistory.js – обрабатывает предыдущие сообщения чата.</li>
</ul>

<p>Краткое описание внутренностей файла realtime.js:</p>

<ul>
<li>Установление соединения ReconnectingWebSocket с /ws/ url. Подобно http и https, соединения websocket могут быть ws, либо wss, то есть незашифрованными или зашифрованными. В коде используется wss, если сайт загружается через https, в противном случае он использует незашифрованный ws режим.</li>
<li>Отправка периодического пульса в url /ws каждые 10 секунд, чтобы сервер знал, что соединение активно;</li>
<li>Преобразование текст пользовательского сообщения чата в json формат и отправить его на сервер.</li>
</ul>

<p>Существует два типа ответов сервера, которые обрабатывает этот файл:</p>

<ol>
<li>Когда сервер отправляет полезную информацию присутствия, содержащую обновленный список активных пользователей вместе с подсчетом анонимов, JavaScript использует эти данные для обновления списка пользователей и подсчета анонимов.</li>
<li>После отправки нового сообщения, сервер возвращает ответ содержащий имя пользователя, отправившего сообщение вместе с отображаемым html. JavaScript использует эти данные для обновления чата пользователя.</li>
</ol>

<p>Реализация обсуждаемого JavaScript:</p>

<pre><code>$(function() {
    // Когда используется HTTPS, задействуется также и WSS.
    $('#all_messages').scrollTop($('#all_messages')[0].scrollHeight);
    var to_focus = $("#message");
    var ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";
    var chatsock = new ReconnectingWebSocket(ws_scheme + '://' + window.location.host + "/ws/");

    chatsock.onmessage = function(message) {

        if($("#no_messages").length){
            $("#no_messages").remove();
        }

        var data = JSON.parse(message.data);
        if(data.type == "presence"){
            //обновляем счетчик гостей
            lurkers = data.payload.lurkers;
            lurkers_ele = document.getElementById("lurkers-count");
            lurkers_ele.innerText = lurkers;

            //обновляем список залогиненных пользователей
            user_list = data.payload.members;
            document.getElementById("loggedin-users-count").innerText = user_list.length;
            user_list_obj = document.getElementById("user-list");
            user_list_obj.innerText = "";

            //alert(user_list);
            for(var i = 0; i &lt; user_list.length; i++ ){
                var user_ele = document.createElement('li');
                user_ele.setAttribute('class', 'list-group-item');
                user_ele.innerText = user_list[i];
                user_list_obj.append(user_ele);
            }

            return;
        }
        var chat = $("#chat")
        var ele = $('&lt;li class="list-group-item"&gt;&lt;/li&gt;')

        ele.append(
            '&lt;strong&gt;'+data.user+'&lt;/strong&gt; : ')

        ele.append(
            data.message)

        chat.append(ele)
        $('#all_messages').scrollTop($('#all_messages')[0].scrollHeight);
    };

    $("#chatform").on("submit", function(event) {
        var message = {
            message: $('#message').val()
        }
        chatsock.send(JSON.stringify(message));
        $("#message").val('').focus();
        return false;
    });

    setInterval(function() {
    chatsock.send(JSON.stringify("heartbeat"));
    }, 10000);
});
</code></pre>

<p>Второй файл JavaScript обрабатывает загрузку предыдущих сообщений чата. Он работает следующим образом:</p>

<ul>
<li>Когда пользователь нажимает кнопку «Load old messages», JavaScript отправляет переменную last_message_id в url /loadhistory.</li>
<li>После получения ответа от сервера, JavaScript обновляет чат с сообщениями в прошлом. Если сервер сообщает, что в скроллинге больше нет сообщений, JavaScript удаляет кнопку «Load old messages».</li>
</ul>

<p>Код loadhistory.js:</p>

<pre><code>$(function() {
    // Когда используется HTTPS, задействуется также и WSS.
    var ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";

    var loadhistorysock = new ReconnectingWebSocket(ws_scheme + '://' + window.location.host + "/loadhistory/");

    loadhistorysock.onmessage = function(message) {

        var data = JSON.parse(message.data);

        new_messages = data.messages

        last_id = data.previous_id

        if(last_id == -1){
            $("#load_old_messages").remove();
            $("#last_message_id").text(last_id)
            if(new_messages.length == 0){
                return;
            }
        }
        else{
            $("#last_message_id").text(last_id)
        }

        var chat = $("#chat")

        for(var i=new_messages.length – 1; i&gt;=0; i--){
            var ele = $('&lt;li class="list-group-item"&gt;&lt;/li&gt;')

            ele.append(
                '&lt;strong&gt;'+new_messages[i]['user']+'&lt;/strong&gt; : '
                )

            ele.append(
                new_messages[i]['message'])

            chat.prepend(ele)
        }

    };

    $("#load_old_messages").on("click", function(event) {
        var message = {
            last_message_id: $('#last_message_id').text()
        }
        loadhistorysock.send(JSON.stringify(message));
        return false;
    });
});
</code></pre>

<p>Ранее уже упоминалось об необходимости отсечения устаревших соединений с веб сайтом. Для этого реализуем celery задачу, которая выполняется каждые 10 секунд и отсекает устаревшие соединения с веб сайтом.</p>

<pre><code>def prune():
    from channels_presence.models import Room
    Room.objects.prune_presences()
</code></pre>

<p>Пакет django-channels-presence упрощает решение этой задачи. Если вы не знакомы с celery, обратитесь к официальной документации.</p>
   
                    </div>
                </article>
            </div>
        </div>
        <div class="row">
            <div class="large-12 columns">
                <dl class="post__tags">
                  <dt class="post__tags-label">Метки:</dt>
                  <dd class="post__tags-list">
                    <ul class="inline-list inline-list_fav-tags js-post-tags">
                        
                        <li class="inline-list__item inline-list__item_tag"><a href="https://www.severcart.ru/blog/tag/python/" rel="tag" class="inline-list__item-link post__tag">python</a>,</li>
                        
                        <li class="inline-list__item inline-list__item_tag"><a href="https://www.severcart.ru/blog/tag/channels/" rel="tag" class="inline-list__item-link post__tag">channels</a>,</li>
                        
                        <li class="inline-list__item inline-list__item_tag"><a href="https://www.severcart.ru/blog/tag/django/" rel="tag" class="inline-list__item-link post__tag">django</a></li>
                        
                    </ul>
                </dd>
                </dl>
            </div>
        </div>
        <div class="row marginBottom">
            <div class="large-3 columns text-left">
                <a href="https://www.severcart.ru/blog/all/command_line_crop_image/">← <br>Кадрирование картинки в командной строке</a>
            </div>
            <div class="large-3 columns text-right">
                <a href="https://www.severcart.ru/blog/all/context_managers_in_python/">→ <br>Контекстные менеджеры в Python</a>
            </div>
        </div>
        <div class="row">
            <div class="large-12 columns"><noindex>
                <div id="disqus_thread"><iframe id="dsq-app3468" name="dsq-app3468" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./Создание чата с использованием Django Channels_files/saved_resource.html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 424px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>
                <script>

                /**
                *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
                *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
                /*
                var disqus_config = function () {
                this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
                this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
                };
                */
                (function() { // DON'T EDIT BELOW THIS LINE
                var d = document, s = d.createElement('script');
                s.src = 'https://www-severcart-org.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
                })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by 

                Disqus.</a>
                </noscript>

               </noindex>
            </div>
        </div>
    </div><!-- Завершение главного контента -->
    <div class="large-4 columns">
        
<div class="widget_categories">
    <h3 class="widget-title">Категории</h3>
    <ul class="no-bullets">
    
        <li class="cat-item"><a href="https://www.severcart.ru/blog/category/%D0%9E%D0%B1%D0%BE%D1%80%D1%83%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Оборудование</a></li>
    
        <li class="cat-item"><a href="https://www.severcart.ru/blog/category/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Программирование</a></li>
    
        <li class="cat-item">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.severcart.ru/blog/category/%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5/">Тестирование</a></li>
    
        <li class="cat-item">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.severcart.ru/blog/category/Python/">Python</a></li>
    
        <li class="cat-item">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.severcart.ru/blog/category/Django/">Django</a></li>
    
        <li class="cat-item"><a href="https://www.severcart.ru/blog/category/Windows/">Windows</a></li>
    
        <li class="cat-item"><a href="https://www.severcart.ru/blog/category/%D0%9F%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B8/">Полезности</a></li>
    
        <li class="cat-item"><a href="https://www.severcart.ru/blog/category/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B4%D0%B5%D0%BD%D1%8C%D0%B3%D0%B8/">Криптоденьги</a></li>
    
    </ul>
</div>

    </div>
</div>
    
        </div>
        <div class="footer">
            <div class="row">
                <div class="large-12 columns">
                    <div class="foter_decorator">
                    <div class="footer_text  text-center">Копирайт © 2019 Severcart</div>
                    </div> <!-- v. 0.10.0 -->
                </div>
            </div>
        </div>
    </div>
        <script src="./Создание чата с использованием Django Channels_files/jquery.min.js"></script><iframe name="ym-native-frame" title="ym-native-frame" frameborder="0" aria-hidden="true" style="opacity: 0 !important; width: 0px !important; height: 0px !important; position: absolute !important; left: 100% !important; bottom: 100% !important; border: 0px !important;" src="./Создание чата с использованием Django Channels_files/saved_resource(1).html"></iframe><ym-measure class="ym-viewport" style="display: block; top: 0px; right: 0px; bottom: 0px; left: 0px; position: fixed; transform: translate(0px, -100%); transform-origin: 0px 0px;"></ym-measure><ym-measure class="ym-zoom" style="bottom: 100%; position: fixed; width: 100vw;"></ym-measure><iframe style="display: none;" src="./Создание чата с использованием Django Channels_files/saved_resource(2).html"></iframe>
        <!--    <script src="js/vendor/what-input.min.js"></script> -->
        <script src="./Создание чата с использованием Django Channels_files/foundation.min.js"></script> 
        <script src="./Создание чата с использованием Django Channels_files/app.js"></script> 
    

<iframe style="position: fixed !important; border: none !important; overflow: hidden !important; visibility: visible !important; z-index: 2147483647 !important; top: auto !important; right: 15px !important; width: 107px !important; height: 52px !important; max-width: 100% !important; max-height: 100% !important; background-color: transparent !important; display: block !important; left: auto !important; bottom: 0px !important;" src="./Создание чата с использованием Django Channels_files/popup.html" id="_hola_popup_iframe__"></iframe></body></html>